from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from sqlalchemy import and_, func
from typing import List, Optional
from app.db.session import get_db
from app.api.v1.auth import get_current_user
from app.models import VulnerabilityAssessment, User, VulnerabilityLevel
from app.schemas import (
    VulnerabilityAssessmentCreate,
    VulnerabilityAssessment as VulnerabilityAssessmentSchema
)

router = APIRouter()

@router.post("/assessments", response_model=VulnerabilityAssessmentSchema)
async def create_vulnerability_assessment(
    assessment_data: VulnerabilityAssessmentCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Create a new vulnerability assessment"""
    # Calculate overall vulnerability and scores
    assessment_dict = assessment_data.dict()
    assessment_dict['assessor_id'] = current_user.id
    
    # Calculate climate resilience score (0-100)
    climate_factors = [
        assessment_data.flood_risk,
        assessment_data.drought_risk,
        assessment_data.extreme_weather_risk
    ]
    climate_risk_score = sum(_vulnerability_to_score(factor) for factor in climate_factors) / len(climate_factors)
    assessment_dict['climate_resilience_score'] = max(0, 100 - climate_risk_score)
    
    # Calculate food security score (0-100)
    food_scores = []
    if assessment_data.food_access_score is not None:
        food_scores.append(assessment_data.food_access_score * 10)
    if assessment_data.nutrition_diversity_score is not None:
        food_scores.append(assessment_data.nutrition_diversity_score * 10)
    if assessment_data.food_affordability_score is not None:
        food_scores.append(assessment_data.food_affordability_score * 10)
    
    if food_scores:
        assessment_dict['food_security_score'] = sum(food_scores) / len(food_scores)
    else:
        assessment_dict['food_security_score'] = 50.0  # Default neutral score
    
    # Calculate overall vulnerability
    assessment_dict['overall_vulnerability'] = _calculate_overall_vulnerability(
        climate_risk_score,
        assessment_dict['food_security_score'],
        assessment_data.poverty_rate,
        assessment_data.healthcare_access
    )
    
    db_assessment = VulnerabilityAssessment(**assessment_dict)
    
    db.add(db_assessment)
    db.commit()
    db.refresh(db_assessment)
    
    return db_assessment

@router.get("/assessments", response_model=List[VulnerabilityAssessmentSchema])
async def list_vulnerability_assessments(
    skip: int = 0,
    limit: int = 100,
    vulnerability_level: Optional[VulnerabilityLevel] = None,
    location: Optional[str] = None,
    lat: Optional[float] = Query(None, description="Latitude for location-based search"),
    lng: Optional[float] = Query(None, description="Longitude for location-based search"),
    radius_km: Optional[float] = Query(50, description="Search radius in kilometers"),
    db: Session = Depends(get_db)
):
    """List vulnerability assessments with optional filters"""
    query = db.query(VulnerabilityAssessment)
    
    if vulnerability_level:
        query = query.filter(VulnerabilityAssessment.overall_vulnerability == vulnerability_level)
    
    if location:
        query = query.filter(VulnerabilityAssessment.location.ilike(f"%{location}%"))
    
    # Location-based filtering
    if lat is not None and lng is not None:
        query = query.filter(
            and_(
                VulnerabilityAssessment.latitude.between(lat - radius_km/111, lat + radius_km/111),
                VulnerabilityAssessment.longitude.between(lng - radius_km/111, lng + radius_km/111)
            )
        )
    
    assessments = query.order_by(VulnerabilityAssessment.assessment_date.desc()).offset(skip).limit(limit).all()
    return assessments

@router.get("/assessments/{assessment_id}", response_model=VulnerabilityAssessmentSchema)
async def get_vulnerability_assessment(assessment_id: int, db: Session = Depends(get_db)):
    """Get a specific vulnerability assessment"""
    assessment = db.query(VulnerabilityAssessment).filter(VulnerabilityAssessment.id == assessment_id).first()
    if not assessment:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Vulnerability assessment not found"
        )
    return assessment

@router.put("/assessments/{assessment_id}", response_model=VulnerabilityAssessmentSchema)
async def update_vulnerability_assessment(
    assessment_id: int,
    assessment_update: VulnerabilityAssessmentCreate,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update vulnerability assessment"""
    assessment = db.query(VulnerabilityAssessment).filter(VulnerabilityAssessment.id == assessment_id).first()
    if not assessment:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Vulnerability assessment not found"
        )
    
    # Check permissions (only assessor or admin can update)
    if assessment.assessor_id != current_user.id and current_user.role.value != "admin":
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not enough permissions to update this assessment"
        )
    
    # Recalculate scores
    update_dict = assessment_update.dict()
    
    # Calculate climate resilience score
    climate_factors = [
        assessment_update.flood_risk,
        assessment_update.drought_risk,
        assessment_update.extreme_weather_risk
    ]
    climate_risk_score = sum(_vulnerability_to_score(factor) for factor in climate_factors) / len(climate_factors)
    update_dict['climate_resilience_score'] = max(0, 100 - climate_risk_score)
    
    # Calculate food security score
    food_scores = []
    if assessment_update.food_access_score is not None:
        food_scores.append(assessment_update.food_access_score * 10)
    if assessment_update.nutrition_diversity_score is not None:
        food_scores.append(assessment_update.nutrition_diversity_score * 10)
    if assessment_update.food_affordability_score is not None:
        food_scores.append(assessment_update.food_affordability_score * 10)
    
    if food_scores:
        update_dict['food_security_score'] = sum(food_scores) / len(food_scores)
    
    # Calculate overall vulnerability
    update_dict['overall_vulnerability'] = _calculate_overall_vulnerability(
        climate_risk_score,
        update_dict.get('food_security_score', assessment.food_security_score),
        assessment_update.poverty_rate,
        assessment_update.healthcare_access
    )
    
    # Update fields
    for field, value in update_dict.items():
        if hasattr(assessment, field):
            setattr(assessment, field, value)
    
    db.commit()
    db.refresh(assessment)
    return assessment

@router.get("/stats/vulnerability-overview")
async def get_vulnerability_overview(db: Session = Depends(get_db)):
    """Get vulnerability assessment overview statistics"""
    total_assessments = db.query(VulnerabilityAssessment).count()
    
    # Count by vulnerability level
    vulnerability_counts = {}
    for level in VulnerabilityLevel:
        count = db.query(VulnerabilityAssessment).filter(
            VulnerabilityAssessment.overall_vulnerability == level
        ).count()
        vulnerability_counts[level.value] = count
    
    # Average scores
    avg_climate_score = db.query(func.avg(VulnerabilityAssessment.climate_resilience_score)).scalar() or 0
    avg_food_security_score = db.query(func.avg(VulnerabilityAssessment.food_security_score)).scalar() or 0
    
    # High-risk communities (high or very high vulnerability)
    high_risk_count = db.query(VulnerabilityAssessment).filter(
        VulnerabilityAssessment.overall_vulnerability.in_([VulnerabilityLevel.HIGH, VulnerabilityLevel.VERY_HIGH])
    ).count()
    
    return {
        "total_assessments": total_assessments,
        "vulnerability_distribution": vulnerability_counts,
        "average_climate_resilience_score": round(float(avg_climate_score), 2),
        "average_food_security_score": round(float(avg_food_security_score), 2),
        "high_risk_communities": high_risk_count
    }

@router.get("/hotspots/high-risk")
async def get_high_risk_hotspots(
    lat: Optional[float] = Query(None, description="Center latitude for regional search"),
    lng: Optional[float] = Query(None, description="Center longitude for regional search"),
    radius_km: Optional[float] = Query(100, description="Search radius in kilometers"),
    db: Session = Depends(get_db)
):
    """Get high-risk vulnerability hotspots"""
    query = db.query(VulnerabilityAssessment).filter(
        VulnerabilityAssessment.overall_vulnerability.in_([VulnerabilityLevel.HIGH, VulnerabilityLevel.VERY_HIGH])
    )
    
    # Location-based filtering if provided
    if lat is not None and lng is not None:
        query = query.filter(
            and_(
                VulnerabilityAssessment.latitude.between(lat - radius_km/111, lat + radius_km/111),
                VulnerabilityAssessment.longitude.between(lng - radius_km/111, lng + radius_km/111)
            )
        )
    
    hotspots = query.order_by(VulnerabilityAssessment.climate_resilience_score.asc()).all()
    
    return {
        "high_risk_communities": len(hotspots),
        "hotspots": [
            {
                "community_name": spot.community_name,
                "location": spot.location,
                "latitude": spot.latitude,
                "longitude": spot.longitude,
                "vulnerability_level": spot.overall_vulnerability.value,
                "climate_resilience_score": spot.climate_resilience_score,
                "food_security_score": spot.food_security_score,
                "population": spot.population,
                "key_risks": _identify_key_risks(spot)
            }
            for spot in hotspots
        ]
    }

@router.get("/recommendations/{assessment_id}")
async def get_vulnerability_recommendations(assessment_id: int, db: Session = Depends(get_db)):
    """Get specific recommendations based on vulnerability assessment"""
    assessment = db.query(VulnerabilityAssessment).filter(VulnerabilityAssessment.id == assessment_id).first()
    if not assessment:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Vulnerability assessment not found"
        )
    
    recommendations = _generate_recommendations(assessment)
    
    return {
        "community_name": assessment.community_name,
        "overall_vulnerability": assessment.overall_vulnerability.value,
        "recommendations": recommendations
    }

# Helper functions
def _vulnerability_to_score(vulnerability_level: VulnerabilityLevel) -> float:
    """Convert vulnerability level to numeric score (0-100)"""
    mapping = {
        VulnerabilityLevel.LOW: 25,
        VulnerabilityLevel.MEDIUM: 50,
        VulnerabilityLevel.HIGH: 75,
        VulnerabilityLevel.VERY_HIGH: 100
    }
    return mapping.get(vulnerability_level, 50)

def _calculate_overall_vulnerability(
    climate_risk_score: float,
    food_security_score: float,
    poverty_rate: Optional[float],
    healthcare_access: Optional[float]
) -> VulnerabilityLevel:
    """Calculate overall vulnerability level"""
    # Combine multiple factors
    factors = [climate_risk_score, 100 - food_security_score]
    
    if poverty_rate is not None:
        factors.append(poverty_rate)
    
    if healthcare_access is not None:
        factors.append(100 - healthcare_access)
    
    avg_vulnerability = sum(factors) / len(factors)
    
    if avg_vulnerability >= 75:
        return VulnerabilityLevel.VERY_HIGH
    elif avg_vulnerability >= 60:
        return VulnerabilityLevel.HIGH
    elif avg_vulnerability >= 40:
        return VulnerabilityLevel.MEDIUM
    else:
        return VulnerabilityLevel.LOW

def _identify_key_risks(assessment: VulnerabilityAssessment) -> List[str]:
    """Identify key risks from assessment"""
    risks = []
    
    if assessment.flood_risk in [VulnerabilityLevel.HIGH, VulnerabilityLevel.VERY_HIGH]:
        risks.append("High flood risk")
    
    if assessment.drought_risk in [VulnerabilityLevel.HIGH, VulnerabilityLevel.VERY_HIGH]:
        risks.append("High drought risk")
    
    if assessment.extreme_weather_risk in [VulnerabilityLevel.HIGH, VulnerabilityLevel.VERY_HIGH]:
        risks.append("High extreme weather risk")
    
    if assessment.food_security_score and assessment.food_security_score < 40:
        risks.append("Low food security")
    
    if assessment.poverty_rate and assessment.poverty_rate > 50:
        risks.append("High poverty rate")
    
    if assessment.healthcare_access and assessment.healthcare_access < 50:
        risks.append("Limited healthcare access")
    
    return risks

def _generate_recommendations(assessment: VulnerabilityAssessment) -> List[dict]:
    """Generate specific recommendations based on assessment"""
    recommendations = []
    
    # Climate adaptation recommendations
    if assessment.flood_risk in [VulnerabilityLevel.HIGH, VulnerabilityLevel.VERY_HIGH]:
        recommendations.append({
            "category": "Climate Adaptation",
            "priority": "High",
            "action": "Implement flood early warning systems and evacuation plans",
            "timeline": "Immediate"
        })
    
    if assessment.drought_risk in [VulnerabilityLevel.HIGH, VulnerabilityLevel.VERY_HIGH]:
        recommendations.append({
            "category": "Water Management",
            "priority": "High", 
            "action": "Develop water storage and conservation infrastructure",
            "timeline": "6-12 months"
        })
    
    # Food security recommendations
    if assessment.food_security_score and assessment.food_security_score < 50:
        recommendations.append({
            "category": "Food Security",
            "priority": "High",
            "action": "Establish community food banks and emergency food reserves",
            "timeline": "3-6 months"
        })
        
        recommendations.append({
            "category": "Agriculture",
            "priority": "Medium",
            "action": "Promote climate-resilient farming practices and crop diversification",
            "timeline": "12+ months"
        })
    
    # Infrastructure recommendations
    if assessment.road_access_quality and assessment.road_access_quality < 5:
        recommendations.append({
            "category": "Infrastructure",
            "priority": "Medium",
            "action": "Improve road access for emergency response and supply delivery",
            "timeline": "12+ months"
        })
    
    if assessment.communication_coverage and assessment.communication_coverage < 5:
        recommendations.append({
            "category": "Communication",
            "priority": "High",
            "action": "Improve mobile and internet coverage for disaster alerts",
            "timeline": "6-12 months"
        })
    
    return recommendations